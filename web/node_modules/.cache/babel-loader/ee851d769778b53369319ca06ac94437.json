{"ast":null,"code":"!function (n, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t((n = n || self).blobs2 = {});\n}(this, function (n) {\n  \"use strict\";\n\n  function a(n) {\n    var t,\n        e,\n        r,\n        o,\n        a = function (n) {\n      for (var t = 2166136261, e = 0; e < n.length; e++) t = Math.imul(t ^ n.charCodeAt(e), 16777619);\n\n      return function () {\n        return t += t << 13, t ^= t >>> 7, t += t << 3, t ^= t >>> 17, (t += t << 5) >>> 0;\n      };\n    }(n);\n\n    return t = a(), e = a(), r = a(), o = a(), function () {\n      var n = (t >>>= 0) + (e >>>= 0) | 0;\n      return t = e ^ e >>> 9, e = (r >>>= 0) + (r << 3) | 0, r = (r = r << 21 | r >>> 11) + (n = n + (o = 1 + (o >>>= 0) | 0) | 0) | 0, (n >>> 0) / 4294967296;\n    };\n  }\n\n  function o(n) {\n    return {\n      x: n.x,\n      y: n.y,\n      handleIn: t({}, n.handleIn),\n      handleOut: t({}, n.handleOut)\n    };\n  }\n\n  function r(e, r) {\n    for (var n = function (n) {\n      function t(n) {\n        return o(e[l(n, e.length)]);\n      }\n\n      r({\n        curr: o(e[n]),\n        index: n,\n        sibling: t,\n        prev: function () {\n          return t(n - 1);\n        },\n        next: function () {\n          return t(n + 1);\n        }\n      });\n    }, t = 0; t < e.length; t++) n(t);\n  }\n\n  function u(n, t) {\n    var e = [];\n    return r(n, function (n) {\n      e.push(t(n));\n    }), e;\n  }\n\n  function i(n, t) {\n    return {\n      x: n.x + t.length * Math.cos(t.angle),\n      y: n.y + t.length * Math.sin(t.angle)\n    };\n  }\n\n  function s(n, f) {\n    return u(n, function (n) {\n      var t,\n          e,\n          r,\n          o,\n          a,\n          u = n.curr,\n          i = n.next,\n          h = n.prev,\n          s = (t = h(), e = i(), r = e.x - t.x, o = -e.y + t.y, (a = Math.atan2(o, r)) < 0 ? Math.abs(a) : 2 * Math.PI - a);\n      return {\n        x: u.x,\n        y: u.y,\n        handleIn: {\n          angle: s + Math.PI,\n          length: f * c(u, h())\n        },\n        handleOut: {\n          angle: s,\n          length: f * c(u, i())\n        }\n      };\n    });\n  }\n\n  function h(n, t, e) {\n    var r = typeof t;\n    if (!e.includes(r)) throw '(blobs2) \"' + n + '\" should have type \"' + e.join(\"|\") + '\" but was \"' + r + '\".';\n  }\n\n  function f(n) {\n    var t = a(String(n.seed));\n    h(\"blobOptions\", n, [\"object\"]), h(\"seed\", n.seed, [\"string\", \"number\"]), h(\"extraPoints\", n.extraPoints, [\"number\"]), h(\"randomness\", n.randomness, [\"number\"]), h(\"size\", n.size, [\"number\"]);\n\n    var e = 1 / (1 + Math.abs(n.randomness) / 10),\n        r = function (n, t) {\n      for (var e = 2 * Math.PI / n, r = [], o = 0; o < n; o++) {\n        var a = t(),\n            u = Math.sin(o * e),\n            i = Math.cos(o * e);\n        r.push({\n          x: .5 + u * a,\n          y: .5 + i * a,\n          handleIn: {\n            angle: 0,\n            length: 0\n          },\n          handleOut: {\n            angle: 0,\n            length: 0\n          }\n        });\n      }\n\n      var h = 4 / 3 * Math.tan(e / 4) / Math.sin(e / 2) / 2;\n      return s(r, h);\n    }(3 + Math.abs(n.extraPoints), function () {\n      return (e + t() * (1 - e)) / 2;\n    }),\n        o = Math.abs(n.size);\n\n    return u(r, function (n) {\n      var t = n.curr;\n      return t.x *= o, t.y *= o, t.handleIn.length *= o, t.handleOut.length *= o, t;\n    });\n  }\n\n  var t = function () {\n    return (t = Object.assign || function (n) {\n      for (var t, e = 1, r = arguments.length; e < r; e++) for (var o in t = arguments[e]) Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);\n\n      return n;\n    }).apply(this, arguments);\n  },\n      l = function (n, t) {\n    return (n % t + t) % t;\n  },\n      c = function (n, t) {\n    return Math.sqrt(Math.pow(n.x - t.x, 2) + Math.pow(n.y - t.y, 2));\n  },\n      d = function (n) {\n    return t = f(n), a = \"M\" + t[0].x + \",\" + t[0].y, r(t, function (n) {\n      var t = n.curr,\n          e = (0, n.next)(),\n          r = i(t, t.handleOut),\n          o = i(e, e.handleIn);\n      a += \"C\" + r.x + \",\" + r.y + \",\" + o.x + \",\" + o.y + \",\" + e.x + \",\" + e.y;\n    }), a;\n    var t, a;\n  };\n\n  n.canvasPath = function (n, e) {\n    return void 0 === e && (e = {}), t = u(f(n), function (n) {\n      var t = n.curr;\n      return t.x += e.offsetX || 0, t.y += e.offsetY || 0, t;\n    }), (a = new Path2D()).moveTo(t[0].x, t[0].y), r(t, function (n) {\n      var t = n.curr,\n          e = (0, n.next)(),\n          r = i(t, t.handleOut),\n          o = i(e, e.handleIn);\n      a.bezierCurveTo(r.x, r.y, o.x, o.y, e.x, e.y);\n    }), a;\n    var t, a;\n  }, n.svg = function (n, t) {\n    void 0 === t && (t = {});\n    var e = d(n),\n        r = Math.floor(n.size),\n        o = void 0 === t.fill ? \"#ec576b\" : t.fill;\n    return ('\\n<svg width=\"' + r + '\" height=\"' + r + '\" viewBox=\"0 0 ' + r + \" \" + r + '\" xmlns=\"http://www.w3.org/2000/svg\">\\n    <path stroke=\"' + (void 0 === t.stroke ? \"none\" : t.stroke) + '\" stroke-width=\"' + (void 0 === t.strokeWidth ? 0 : t.strokeWidth) + '\" fill=\"' + o + '\" d=\"' + e + '\"/>\\n</svg>').trim();\n  }, n.svgPath = d, Object.defineProperty(n, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"sources":["../internal/rand.ts","../internal/util.ts","../internal/gen.ts","../public/blobs.ts","../internal/render/svg.ts","../internal/render/canvas.ts"],"names":["rand","seed","str","h","i","length","Math","imul","charCodeAt","a","b","c","d","t","seedGenerator","xfnv1a","copyPoint","p","x","y","handleIn","handleOut","forPoints","points","callback","sibling","pos","mod","curr","index","prev","next","mapPoints","out","args","push","dx","dy","angle","atan2","abs","PI","expandHandle","point","handle","cos","sin","smooth","strength","_a","distance","n","sqrt","pointCount","offset","randPointOffset","pointX","pointY","smoothingStrength","tan","typeCheck","name","val","expected","actual","includes","join","genFromOptions","blobOptions","rgen","String","extraPoints","randomness","size","rangeStart","genBlob","canvasOptions","offsetX","offsetY","svgOptions","path","svgPath","floor","fill","undefined","stroke","strokeWidth","trim","getNext","currControl","nextControl","Path2D","moveTo","currHandle","nextHandle","bezierCurveTo"],"mappings":"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","sourcesContent":["// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n","import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n","import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nconst typeCheck = (name: string, val: any, expected: string[]) => {\n    const actual = typeof val;\n    if (!expected.includes(actual)) {\n        throw `(blobs2) \"${name}\" should have type \"${expected.join(\"|\")}\" but was \"${actual}\".`;\n    }\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    typeCheck(\"blobOptions\", blobOptions, [\"object\"]);\n    typeCheck(\"seed\", blobOptions.seed, [\"string\", \"number\"]);\n    typeCheck(\"extraPoints\", blobOptions.extraPoints, [\"number\"]);\n    typeCheck(\"randomness\", blobOptions.randomness, [\"number\"]);\n    typeCheck(\"size\", blobOptions.size, [\"number\"]);\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + Math.abs(blobOptions.randomness) / 10);\n\n    const points = genBlob(\n        3 + Math.abs(blobOptions.extraPoints),\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = Math.abs(blobOptions.size);\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n","import {genFromOptions} from \"../internal/gen\";\nimport {renderPath} from \"../internal/render/svg\";\nimport {renderPath2D} from \"../internal/render/canvas\";\nimport {mapPoints} from \"../internal/util\";\n\nexport interface BlobOptions {\n    seed: string | number;\n    extraPoints: number;\n    randomness: number;\n    size: number;\n}\n\nexport interface CanvasOptions {\n    offsetX?: number;\n    offsetY?: number;\n}\n\nexport interface SvgOptions {\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n}\n\nexport const canvasPath = (blobOptions: BlobOptions, canvasOptions: CanvasOptions = {}): Path2D => {\n    return renderPath2D(\n        mapPoints(genFromOptions(blobOptions), ({curr}) => {\n            curr.x += canvasOptions.offsetX || 0;\n            curr.y += canvasOptions.offsetY || 0;\n            return curr;\n        }),\n    );\n};\n\nexport const svg = (blobOptions: BlobOptions, svgOptions: SvgOptions = {}): string => {\n    const path = svgPath(blobOptions);\n    const size = Math.floor(blobOptions.size);\n    const fill = svgOptions.fill === undefined ? \"#ec576b\" : svgOptions.fill;\n    const stroke = svgOptions.stroke === undefined ? \"none\" : svgOptions.stroke;\n    const strokeWidth = svgOptions.strokeWidth === undefined ? 0 : svgOptions.strokeWidth;\n    return `\n<svg width=\"${size}\" height=\"${size}\" viewBox=\"0 0 ${size} ${size}\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path stroke=\"${stroke}\" stroke-width=\"${strokeWidth}\" fill=\"${fill}\" d=\"${path}\"/>\n</svg>`.trim();\n};\n\nexport const svgPath = (blobOptions: BlobOptions): string => {\n    return renderPath(genFromOptions(blobOptions));\n};\n","import {Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nexport interface RenderOptions {\n    // Viewport size.\n    width: number;\n    height: number;\n\n    // Transformation applied to all drawn points.\n    transform?: string;\n\n    // Declare whether the path should be closed.\n    // This option is currently always true.\n    closed: true;\n\n    // Output path styling.\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n\n    // Option to render guides (points, handles and viewport).\n    guides?: boolean;\n    boundingBox?: boolean;\n}\n\nexport const renderPath = (points: Point[]): string => {\n    // Render path data attribute from points and handles.\n    let path = `M${points[0].x},${points[0].y}`;\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currControl = expandHandle(curr, curr.handleOut);\n        const nextControl = expandHandle(next, next.handleIn);\n        path += `C${currControl.x},${currControl.y},${nextControl.x},${nextControl.y},${next.x},${next.y}`;\n    });\n    return path;\n};\n\n// Renders the input points to an editable data structure which can be rendered to svg.\nexport const renderEditable = (points: Point[], options: RenderOptions): XmlElement => {\n    const stroke = options.stroke || (options.guides ? \"black\" : \"none\");\n    const strokeWidth = options.strokeWidth || (options.guides ? 1 : 0);\n\n    const xmlRoot = new XmlElement(\"svg\");\n    xmlRoot.attributes.width = options.width;\n    xmlRoot.attributes.height = options.height;\n    xmlRoot.attributes.viewBox = `0 0 ${options.width} ${options.height}`;\n    xmlRoot.attributes.xmlns = \"http://www.w3.org/2000/svg\";\n\n    const xmlContentGroup = new XmlElement(\"g\");\n    xmlContentGroup.attributes.transform = options.transform || \"\";\n\n    const xmlBlobPath = new XmlElement(\"path\");\n    xmlBlobPath.attributes.stroke = stroke;\n    xmlBlobPath.attributes[\"stroke-width\"] = strokeWidth;\n    xmlBlobPath.attributes.fill = options.fill || \"none\";\n    xmlBlobPath.attributes.d = renderPath(points);\n\n    xmlContentGroup.children.push(xmlBlobPath);\n    xmlRoot.children.push(xmlContentGroup);\n\n    // Render guides if configured to do so.\n    if (options.guides) {\n        const color = options.stroke || \"black\";\n        const size = options.strokeWidth || 1;\n\n        // Bounding box.\n        if (options.boundingBox) {\n            const xmlBoundingRect = new XmlElement(\"rect\");\n            xmlBoundingRect.attributes.x = 0;\n            xmlBoundingRect.attributes.y = 0;\n            xmlBoundingRect.attributes.width = options.width;\n            xmlBoundingRect.attributes.height = options.height;\n            xmlBoundingRect.attributes.fill = \"none\";\n            xmlBoundingRect.attributes.stroke = color;\n            xmlBoundingRect.attributes[\"stroke-width\"] = 2 * size;\n            xmlBoundingRect.attributes[\"stroke-dasharray\"] = 2 * size;\n            xmlContentGroup.children.push(xmlBoundingRect);\n        }\n\n        // Points and handles.\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n            const currControl = expandHandle(curr, curr.handleOut);\n            const nextControl = expandHandle(next, next.handleIn);\n\n            const xmlOutgoingHandleLine = new XmlElement(\"line\");\n            xmlOutgoingHandleLine.attributes.x1 = curr.x;\n            xmlOutgoingHandleLine.attributes.y1 = curr.y;\n            xmlOutgoingHandleLine.attributes.x2 = currControl.x;\n            xmlOutgoingHandleLine.attributes.y2 = currControl.y;\n            xmlOutgoingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlOutgoingHandleLine.attributes.stroke = color;\n\n            const xmlIncomingHandleLine = new XmlElement(\"line\");\n            xmlIncomingHandleLine.attributes.x1 = next.x;\n            xmlIncomingHandleLine.attributes.y1 = next.y;\n            xmlIncomingHandleLine.attributes.x2 = nextControl.x;\n            xmlIncomingHandleLine.attributes.y2 = nextControl.y;\n            xmlIncomingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlIncomingHandleLine.attributes.stroke = color;\n            xmlIncomingHandleLine.attributes[\"stroke-dasharray\"] = 2 * size;\n\n            const xmlOutgoingHandleCircle = new XmlElement(\"circle\");\n            xmlOutgoingHandleCircle.attributes.cx = currControl.x;\n            xmlOutgoingHandleCircle.attributes.cy = currControl.y;\n            xmlOutgoingHandleCircle.attributes.r = size;\n            xmlOutgoingHandleCircle.attributes.fill = color;\n\n            const xmlIncomingHandleCircle = new XmlElement(\"circle\");\n            xmlIncomingHandleCircle.attributes.cx = nextControl.x;\n            xmlIncomingHandleCircle.attributes.cy = nextControl.y;\n            xmlIncomingHandleCircle.attributes.r = size;\n            xmlIncomingHandleCircle.attributes.fill = color;\n\n            const xmlPointCircle = new XmlElement(\"circle\");\n            xmlPointCircle.attributes.cx = curr.x;\n            xmlPointCircle.attributes.cy = curr.y;\n            xmlPointCircle.attributes.r = 2 * size;\n            xmlPointCircle.attributes.fill = color;\n\n            xmlContentGroup.children.push(xmlOutgoingHandleLine);\n            xmlContentGroup.children.push(xmlIncomingHandleLine);\n            xmlContentGroup.children.push(xmlOutgoingHandleCircle);\n            xmlContentGroup.children.push(xmlIncomingHandleCircle);\n            xmlContentGroup.children.push(xmlPointCircle);\n        });\n    }\n\n    return xmlRoot;\n};\n\n// Structured element with tag, attributes and children.\nexport class XmlElement {\n    public attributes: Record<string, string | number> = {};\n    public children: any[] = [];\n\n    public constructor(public tag: string) {}\n\n    public render(): string {\n        const attributes = this.renderAttributes();\n        const content = this.renderChildren();\n        if (content === \"\") {\n            return `<${this.tag}${attributes}/>`;\n        }\n        return `<${this.tag}${attributes}>${content}</${this.tag}>`;\n    }\n\n    private renderAttributes(): string {\n        const attributes = Object.keys(this.attributes);\n        if (attributes.length === 0) return \"\";\n        let out = \"\";\n        for (const attribute of attributes) {\n            out += ` ${attribute}=\"${this.attributes[attribute]}\"`;\n        }\n        return out;\n    }\n\n    private renderChildren(): string {\n        let out = \"\";\n        for (const child of this.children) {\n            out += child.render();\n        }\n        return out;\n    }\n}\n","import {Coord, Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nconst pointSize = 2;\nconst infoSpacing = 20;\n\nexport const clear = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\nexport const drawInfo = (ctx: CanvasRenderingContext2D, pos: number, label: string, value: any) => {\n    ctx.fillText(`${label}: ${value}`, infoSpacing, (pos + 1) * infoSpacing);\n};\n\nconst drawLine = (ctx: CanvasRenderingContext2D, a: Coord, b: Coord, style: string) => {\n    const backupStrokeStyle = ctx.strokeStyle;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.strokeStyle = backupStrokeStyle;\n};\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, p: Coord, style: string) => {\n    const backupFillStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);\n    ctx.fillStyle = style;\n    ctx.fill();\n    ctx.fillStyle = backupFillStyle;\n};\n\nexport const drawClosed = (ctx: CanvasRenderingContext2D, debug: boolean, points: Point[]) => {\n    if (points.length < 2) throw new Error(\"not enough points\");\n\n    // Draw debug points.\n    if (debug) {\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n\n            // Compute coordinates of handles.\n            const currHandle = expandHandle(curr, curr.handleOut);\n            const nextHandle = expandHandle(next, next.handleIn);\n\n            drawPoint(ctx, curr, \"\");\n            drawLine(ctx, curr, currHandle, \"#ccc\");\n            drawLine(ctx, next, nextHandle, \"#b6b\");\n        });\n    }\n\n    ctx.stroke(renderPath2D(points));\n};\n\nexport const renderPath2D = (points: Point[]): Path2D => {\n    const path = new Path2D();\n    path.moveTo(points[0].x, points[0].y);\n\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currHandle = expandHandle(curr, curr.handleOut);\n        const nextHandle = expandHandle(next, next.handleIn);\n        path.bezierCurveTo(currHandle.x, currHandle.y, nextHandle.x, nextHandle.y, next.x, next.y);\n    });\n\n    return path;\n};\n"]},"metadata":{},"sourceType":"script"}